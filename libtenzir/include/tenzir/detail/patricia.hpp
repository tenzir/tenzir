/*
 * Copyright (c) 2019, 2020, 2021 SiKol Ltd.
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#pragma once

// #define SK_PATRICIA_TRACE

#include <algorithm>
#include <array>
#include <bit>
#include <climits>
#include <cstddef>
#include <cstring>
#include <memory>
#include <optional>
#include <ranges>
#include <span>

#if defined(SK_PATRICIA_TRACE) && !defined(NDEBUG)

#  include <iostream>
#  include <set>

#  define SK_PATRICIA_TRACE_MSG(...) fmt::print(__VA_ARGS__)
#else
#  define SK_PATRICIA_TRACE_MSG(...) ((void)0)
#endif

#if !defined(NDEBUG) && !defined(SK_PATRICIA_NO_INVARIANTS)
#  include <cassert>
#  if __has_include(<fmt/core.h>)
#    include <fmt/core.h>
#    define SK_PATRICIA_HAVE_FMT
#  endif
#  define SK_PATRICIA_INVARIANT(c) assert(c)
#else
#  define SK_PATRICIA_INVARIANT(c) ((void)0)
#endif

namespace sk {

using bit_t = std::size_t;

/*************************************************************************
 *
 * patricia_key: store an std::span<> along with its bit-length.
 *
 */

struct patricia_key {
  std::span<std::byte const> key;
  bit_t bits = 0;

  patricia_key() noexcept = default;

  // NOLINTNEXTLINE non-explicit constructor
  patricia_key(std::span<std::byte const> key_, bit_t bits_ = 0) noexcept
    : key(key_), bits(bits_ ? bits_ : (key.size() * CHAR_BIT)) {
    if (bits > 0) {
      std::size_t need_bytes = 1 + ((bits - 1) / CHAR_BIT);

      if (key.size() > need_bytes) {
        key = key.subspan(0, need_bytes);
      }

      SK_PATRICIA_INVARIANT(key.size() >= need_bytes);
    }
  }

  // NOLINTNEXTLINE non-explicit constructor
  patricia_key(char const* string, bit_t bits_ = 0) noexcept
    : patricia_key(as_bytes(std::span(string, std::strlen(string))), bits_) {
  }

  patricia_key(patricia_key const& other) noexcept = default;

  template <std::ranges::contiguous_range Range>
  // NOLINTNEXTLINE non-explicit constructor; forwarding constructor
  patricia_key(Range&& r, bit_t bits_ = 0) noexcept
    : patricia_key(
      as_bytes(
        std::span<std::add_const_t<std::ranges::range_value_t<Range>>>(r)),
      bits_) {
  }

  auto operator=(patricia_key const& other) noexcept -> patricia_key& = default;

  [[nodiscard]] auto size_bytes() const noexcept -> std::size_t {
    return key.size();
  }

  [[nodiscard]] auto size_bits() const noexcept -> bit_t {
    return bits;
  }

  [[nodiscard]] auto empty() const noexcept -> bool {
    return bits == 0;
  }

  [[nodiscard]] auto test_bit(bit_t bit) const noexcept -> bool {
    auto byten = bit / CHAR_BIT;
    if (byten >= key.size()) {
      return false;
    }

    auto byte = static_cast<unsigned>(key[byten]);

    // auto test_mask = 0x80 >> (bit % CHAR_BIT);
    // bool ret = (byte & test_mask) != 0;

    unsigned ret = (byte >> (CHAR_BIT - ((bit % CHAR_BIT) + 1))) & 1;
    return ret;
  }
};

namespace detail {

/*************************************************************************
 * bit_diff()
 */

inline auto bit_diff(patricia_key const& a, patricia_key const& b) noexcept
  -> bit_t {
  auto mm = std::ranges::mismatch(a.key, b.key);

  bit_t byte = std::distance(a.key.begin(), mm.in1);

  SK_PATRICIA_TRACE_MSG("[bit_diff: alen={} blen={} diff byte={}]\n",
                        a.size_bytes(), b.size_bytes(), byte);

  if (byte == a.size_bytes() || byte == b.size_bytes()) {
    return byte * CHAR_BIT;
  }

  std::byte diff = a.key[byte] ^ b.key[byte];
  auto match = std::countl_zero(static_cast<unsigned char>(diff));
  return (byte * CHAR_BIT) + match;
}

} // namespace detail

inline auto operator==(patricia_key const& a, patricia_key const& b) noexcept
  -> bool {
  /*
   * This function is performance-critical since it's called on every
   * node lookup; most of the time in find_node() is actually calling
   * this.
   */

  auto a_size_bytes = a.size_bytes();
  auto a_size_bits = a.size_bits();
  auto b_size_bytes = b.size_bytes();
  auto b_size_bits = b.size_bits();

  if (a_size_bits != b_size_bits) {
    return false;
  }

  if (a_size_bytes == 0 && b_size_bytes == 0) {
    return true;
  }

  if ((a_size_bits % CHAR_BIT) == 0) {
    return std::memcmp(a.key.data(), b.key.data(), a_size_bytes) == 0;
  }

  SK_PATRICIA_INVARIANT(a_size_bytes == b_size_bytes);

  std::size_t i = 0;
  for (; i < (a_size_bytes - 1); ++i) {
    SK_PATRICIA_INVARIANT(i < a.key.size());
    SK_PATRICIA_INVARIANT(i < b.key.size());

    if (a.key[i] != b.key[i]) {
      return false;
    }
  }

  SK_PATRICIA_INVARIANT(i == (a_size_bytes - 1));

  std::byte mask = std::byte{0xFF} << (CHAR_BIT - (a_size_bits % CHAR_BIT));

  SK_PATRICIA_TRACE_MSG("a_bits={}, b_bits={}, mask={:08b}, mod={}\n",
                        a_size_bits, b_size_bits, mask, a_size_bits % CHAR_BIT);

  return ((a.key[i] ^ b.key[i]) & mask) == std::byte{0};
}

/*
 * Compare the first a.size_bits() bits of 'a' to 'b'.
 */
inline auto
prefix_compare(patricia_key const& a, patricia_key const& b) noexcept -> bool {
  auto size_bytes = a.size_bytes();
  auto bits = a.size_bits();

  if (bits > b.size_bits()) {
    return false;
  }

  if (size_bytes == 0) {
    return true;
  }

  if ((bits % CHAR_BIT) == 0) {
    return std::memcmp(a.key.data(), b.key.data(), size_bytes) == 0;
  }

  SK_PATRICIA_INVARIANT(a.size_bytes() <= b.size_bytes());

  std::size_t i = 0;
  for (; i < (size_bytes - 1); ++i) {
    SK_PATRICIA_INVARIANT(i < a.key.size());
    SK_PATRICIA_INVARIANT(i < b.key.size());

    if (a.key[i] != b.key[i]) {
      return false;
    }
  }

  SK_PATRICIA_INVARIANT(i == (size_bytes - 1));

  std::byte mask = std::byte{0xFF} << (CHAR_BIT - (bits % CHAR_BIT));

  SK_PATRICIA_TRACE_MSG("bits={}, mask={:08b}, mod={}\n", bits, mask,
                        bits % CHAR_BIT);

  return ((a.key[i] ^ b.key[i]) & mask) == std::byte{0};
}

/*************************************************************************
 *
 * patricia_node<T>: one node in the trie that stores an object of type T.
 *
 */

template <typename T, typename Allocator>
class patricia_node { // NOLINT uninitialized field
  patricia_node() noexcept = default;

public:
  using node_ptr = patricia_node<T, Allocator>*;
  using const_node_ptr = patricia_node<T, Allocator> const*;

  using allocator_type =
    typename std::allocator_traits<Allocator>::template rebind_alloc<std::byte>;

  enum edge { left = 0, right = 1 };

  static auto make_node(patricia_key const& key = {}, bit_t bit = 0)
    -> node_ptr {
    allocator_type allocator;

    auto bytes = allocator.allocate(sizeof(patricia_node<T, Allocator>)
                                    + (key.size_bytes() - 1));

    auto ptr = new (bytes) patricia_node<T, Allocator>;
    ptr->bit = bit;

    if (!key.empty()) {
      std::ranges::copy(key.key, &ptr->_key_bytes[0]);
      ptr->key = patricia_key(std::span(&ptr->_key_bytes[0], key.size_bytes()),
                              key.size_bits());
    }

    SK_PATRICIA_TRACE_MSG("[NODE] make node @ {}\n", (void*)ptr);

    return ptr;
  }

  // NOLINTNEXTLINE missing operator new
  static void operator delete(void* ptr) noexcept {
    allocator_type allocator;

    auto node = static_cast<patricia_node<T, Allocator>*>(ptr);

    SK_PATRICIA_TRACE_MSG("[NODE] delete node @ {}\n", ptr);

    auto bytes = reinterpret_cast<std::byte*>(ptr);
    allocator.deallocate(bytes, sizeof(patricia_node<T, Allocator>)
                                  + (node->key.size_bytes() - 1));
  }

  static auto make_node(patricia_node* parent, patricia_node* l,
                        patricia_node* r, bit_t bit) {
    auto node = make_node({}, bit);
    node->parent = parent;

    node->edges[left] = l;
    if (l) {
      l->parent = node;
    }

    node->edges[right] = r;
    if (r) {
      r->parent = node;
    }

    SK_PATRICIA_TRACE_MSG("[make_node: node<{}>, parent<{}>/<{}>, "
                          "left<{}>/<{}>, right<{}>/<{}>]\n",
                          (void*)node, (void*)parent, (void*)node->parent,
                          (void*)l, (void*)(l ? l->parent : nullptr), (void*)r,
                          (void*)(r ? r->parent : nullptr));
    return node;
  }

  auto copy() const -> patricia_node* {
    auto new_node = make_node(key, bit);
    new_node->value = value;
    new_node->parent = parent;

    if (edges[left]) {
      new_node->edges[left] = edges[left]->copy();
    }

    if (edges[right]) {
      new_node->edges[right] = edges[right]->copy();
    }

    return new_node;
  }

  patricia_node(patricia_node const&) = delete;
  patricia_node(patricia_node&&) = delete;
  auto operator=(patricia_node const&) = delete;
  auto operator=(patricia_node&&) = delete;

  ~patricia_node() noexcept(std::is_nothrow_destructible_v<T>) {
    delete edges[0];
    delete edges[1];
  }

  void clear_value() noexcept(std::is_nothrow_destructible_v<T>) {
    // Can't reset the key because we need to know its byte length
    // for operator delete.
    key.bits = 0;
    value.reset();
  }

  [[nodiscard]] auto edgecount() const noexcept -> int {
    return static_cast<int>(2 - std::ranges::count(edges, nullptr));
  }

  [[nodiscard]] auto leftedge() noexcept -> node_ptr& {
    return edges[left];
  }

  [[nodiscard]] auto leftedge() const noexcept -> const_node_ptr {
    return edges[left];
  }

  [[nodiscard]] auto rightedge() noexcept -> node_ptr& {
    return edges[right];
  }

  [[nodiscard]] auto rightedge() const noexcept -> const_node_ptr {
    return edges[right];
  }

  // Detach the left or right edge from this node and return it.
  auto detach(edge e) noexcept -> node_ptr {
    if (!edges[e]) {
      return nullptr;
    }

    auto* p = std::exchange(edges[e], nullptr);
    p->parent = nullptr;
    return p;
  }

  // Attach a new node to this one.  If an existing node was present,
  // detach and return it.
  auto attach(edge e, node_ptr n) noexcept -> node_ptr {
    SK_PATRICIA_TRACE_MSG(
      "[attach: node<{}> gains n<{}> at {}, replaces <{}>]\n", (void*)this,
      (void*)n, e == left ? "left" : "right", (void*)edges[e]);
    auto prev = detach(e);
    edges[e] = n;
    n->parent = this;
    return prev;
  }

  // Return whether the given node is our left or right edge.
  auto which(node_ptr n) const noexcept -> edge {
    if (leftedge() == n) {
      return left;
    } else {
      SK_PATRICIA_INVARIANT(rightedge() == n);
      return right;
    }
  }

  bit_t bit = 0;
  std::array<node_ptr, 2> edges{};
  patricia_node* parent = nullptr;
  std::optional<T> value;
  patricia_key key;
  std::byte _key_bytes[1]; // must be the last member
};

/*************************************************************************
 *
 * patricia_iterator<T>: an iterator for a patricia_trie.
 *
 */

template <typename T, typename Alloc = std::allocator<T>,
          bool is_const_iterator = false>
class patricia_iterator {
  using node_type = patricia_node<T, Alloc>;
  using node_pointer
    = std::conditional_t<is_const_iterator, node_type const*, node_type*>;
  using const_node_pointer = node_type const*;

  node_pointer current = nullptr;

  auto _advance() noexcept -> void {
    do {
      SK_PATRICIA_TRACE_MSG("iterator: at {}\n", (void*)current);

      if (current->leftedge()) {
        current = current->leftedge();
        continue;
      }

      if (current->rightedge()) {
        current = current->rightedge();
        continue;
      }

      // If we can't go either left or right, back up until we
      // find a node where we went left last time and can go
      // right this time.  If we walk up to the root and don't
      // find any right branch, stop iterating.
      for (;;) {
        SK_PATRICIA_TRACE_MSG("iterator: walking up, current={}\n",
                              (void*)current);
        auto here_is_left = (current == current->parent->leftedge());
        auto parent_has_right = (current->parent->rightedge() != nullptr);

        if (here_is_left && parent_has_right) {
          current = current->parent->rightedge();
          break;
        }

        current = current->parent;
        if (!current->parent) {
          SK_PATRICIA_TRACE_MSG("iterator: at root and nowhere to go\n");
          current = nullptr;
          return;
        }
      }
    } while (current && !current->value);
  }

public:
  using iterator_category = std::forward_iterator_tag;
  using difference_type = std::ptrdiff_t;
  using value_type
    = std::conditional_t<is_const_iterator, std::add_const_t<T>, T>;
  using const_value_type = std::add_const_t<value_type>;
  using pointer = value_type*;
  using const_pointer = const_value_type*;
  using reference = value_type&;
  using const_reference = const_value_type&;

  explicit patricia_iterator() noexcept = default;

  explicit patricia_iterator(node_pointer node) noexcept : current(node) {
    if (current && !current->value) {
      _advance();
    }
  }

  auto operator*() noexcept -> reference {
    SK_PATRICIA_INVARIANT(current != nullptr && current->value.has_value());
    return *current->value;
  }

  auto operator*() const noexcept -> const_reference {
    SK_PATRICIA_INVARIANT(current != nullptr && current->value.has_value());
    return *current->value;
  }

  auto operator->() noexcept -> pointer {
    SK_PATRICIA_INVARIANT(current != nullptr && current->value.has_value());
    return std::addressof(*current->value);
  }

  auto operator->() const noexcept -> const_pointer {
    SK_PATRICIA_INVARIANT(current != nullptr && current->value.has_value());
    return std::addressof(*current->value);
  }

  auto operator++() noexcept -> patricia_iterator& {
    _advance();
    return *this;
  }

  auto operator++(int) noexcept -> patricia_iterator {
    auto ret(*this);
    ++*this;
    return ret;
  }

  auto get_node() const noexcept -> node_pointer {
    return current;
  }

  template <typename T_, typename Alloc_, bool is_const_>
  friend auto
  operator==(patricia_iterator<T_, Alloc_, is_const_> const& a,
             patricia_iterator<T_, Alloc_, is_const_> const& b) noexcept
    -> bool;
};

template <typename T, typename Alloc, bool is_const>
auto operator==(patricia_iterator<T, Alloc, is_const> const& a,
                patricia_iterator<T, Alloc, is_const> const& b) noexcept
  -> bool {
  SK_PATRICIA_TRACE_MSG("iterator::op==: a.current={} b.current={}\n",
                        (void*)a.current, (void*)b.current);
  return a.current == b.current;
}

/*************************************************************************
 *
 * patricia_trie<T>: a trie that stores objects of type T.
 *
 */

template <typename T, typename Alloc = std::allocator<T>>
class patricia_trie {
public:
  using key_type = patricia_key;

  using size_type = std::size_t;
  using difference_type = std::ptrdiff_t;

  using value_type = T;
  using const_value_type = value_type const;

  using reference = value_type&;
  using const_reference = const_value_type&;
  using pointer = value_type*;
  using const_pointer = const_value_type*;

  using node_type = patricia_node<value_type, Alloc>;
  using const_node_type = node_type const;

  using value_pointer = value_type*;
  using const_value_pointer = value_type const*;

  using node_pointer = node_type*;
  using const_node_pointer = node_type const*;

  using iterator = patricia_iterator<T, Alloc, false>;
  using const_iterator = patricia_iterator<T, Alloc, true>;

private:
  node_pointer root = nullptr;

public:
  patricia_trie() noexcept = default;
  patricia_trie(patricia_trie&&) noexcept;
  patricia_trie(patricia_trie const&);
  ~patricia_trie() noexcept(std::is_nothrow_destructible_v<node_type>);

  auto operator=(patricia_trie&&) noexcept -> patricia_trie&;
  auto operator=(patricia_trie const&) -> patricia_trie&;

  // Node operations.
  [[nodiscard]] auto find_node(patricia_key const& key) const noexcept
    -> const_node_pointer;

  [[nodiscard]] auto find_node(patricia_key const& key) noexcept
    -> node_pointer;

  [[nodiscard]] auto prefix_match(patricia_key const& key) noexcept
    -> node_pointer;

  auto insert_node(patricia_key const& key) -> node_pointer;

  auto remove_node(node_pointer) noexcept(
    std::is_nothrow_destructible_v<node_type>) -> void;

  [[nodiscard]] auto root_node() noexcept -> node_pointer;
  [[nodiscard]] auto root_node() const noexcept -> const_node_pointer;

  // Iterator operations.
  auto begin() noexcept -> iterator;
  auto begin() const noexcept -> const_iterator;
  auto cbegin() const noexcept -> const_iterator;

  auto end() noexcept -> iterator;
  auto end() const noexcept -> const_iterator;
  auto cend() const noexcept -> const_iterator;

  [[nodiscard]] auto find(patricia_key const& key) const noexcept
    -> const_iterator;

  [[nodiscard]] auto find(patricia_key const& key) noexcept -> iterator;

  auto
  erase(iterator const&) noexcept(std::is_nothrow_destructible_v<node_type>)
    -> size_type;

  // Value operations.
  auto insert(patricia_key const& key, T const& value) -> bool;

  auto remove(patricia_key const& key) noexcept(
    std::is_nothrow_destructible_v<node_type>) -> bool;

  auto clear() noexcept(std::is_nothrow_destructible_v<node_type>) -> void;

  [[nodiscard]] auto empty() const noexcept -> bool;

  // Debugging functions.
#ifdef SK_PATRICIA_INVARIANT

  template <typename... Args>
  void bugcheck(std::string const&, Args&&... args) const noexcept;

#endif

#ifdef SK_PATRICIA_TRACE
  [[nodiscard]] auto format_key(patricia_key const& k) const -> std::string;

  auto print(const_node_pointer node, int indent = 0) const -> std::string;

  auto check(const_node_pointer node,
             std::shared_ptr<std::set<const_node_pointer>> seen = {}) const
    -> void;
#endif // SK_PATRICIA_TRACE
};

/*************************************************************************
 * patrcia_trie<T> copy constructor
 */
template <typename T, typename Allocator>
patricia_trie<T, Allocator>::patricia_trie(patricia_trie const& other)
  : root(other.root->copy()) {
}

/*************************************************************************
 * patrcia_trie<T> move constructor
 */
template <typename T, typename Allocator>
patricia_trie<T, Allocator>::patricia_trie(patricia_trie&& other) noexcept
  : root(std::exchange(other.root, nullptr)) {
}

/*************************************************************************
 * patrcia_trie<T> copy assignment
 */
template <typename T, typename Allocator>
auto patricia_trie<T, Allocator>::operator=(patricia_trie const& other)
  -> patricia_trie& {
  if (&other != this) {
    delete root;
    root = other.root->copy();
  }

  return *this;
}

/*************************************************************************
 * patrcia_trie<T> move assignment
 */
template <typename T, typename Allocator>
auto patricia_trie<T, Allocator>::operator=(patricia_trie&& other) noexcept
  -> patricia_trie& {
  if (&other != this) {
    root = std::exchange(other.root, nullptr);
  }
  return *this;
}

/*************************************************************************
 * patricia_trie<T>::~patricia_trie
 */
template <typename T, typename Alloc>
patricia_trie<T, Alloc>::~patricia_trie() noexcept(
  std::is_nothrow_destructible_v<node_type>) {
  delete root;
}

/*************************************************************************
 * iterators
 */

template <typename T, typename Allocator>
auto patricia_trie<T, Allocator>::begin() noexcept -> iterator {
  return iterator(root);
}

template <typename T, typename Allocator>
auto patricia_trie<T, Allocator>::begin() const noexcept -> const_iterator {
  return const_iterator(root);
}

template <typename T, typename Allocator>
auto patricia_trie<T, Allocator>::cbegin() const noexcept -> const_iterator {
  return const_iterator(root);
}

template <typename T, typename Allocator>
auto patricia_trie<T, Allocator>::end() noexcept -> iterator {
  return iterator();
}

template <typename T, typename Allocator>
auto patricia_trie<T, Allocator>::end() const noexcept -> const_iterator {
  return const_iterator();
}

template <typename T, typename Allocator>
auto patricia_trie<T, Allocator>::cend() const noexcept -> const_iterator {
  return const_iterator();
}

template <typename T, typename Allocator>
auto patricia_trie<T, Allocator>::root_node() noexcept -> node_pointer {
  return root;
}

template <typename T, typename Allocator>
auto patricia_trie<T, Allocator>::root_node() const noexcept
  -> const_node_pointer {
  return root;
}

/*************************************************************************
 * patricia_trie<T>::clear
 */
template <typename T, typename Alloc>
auto patricia_trie<T, Alloc>::clear() noexcept(
  std::is_nothrow_destructible_v<node_type>) -> void {
  delete std::exchange(root, nullptr);
}

/*************************************************************************
 * patricia_trie<T>::empty
 */
template <typename T, typename Allocator>
auto patricia_trie<T, Allocator>::empty() const noexcept -> bool {
  return !root || (!root->value && !root->edges[0] && !root->edges[1]);
}

/*************************************************************************
 * patricia_trie<T>::insert
 */
template <typename T, typename Allocator>
auto patricia_trie<T, Allocator>::insert(patricia_key const& key,
                                         T const& value) -> bool {
  auto node = insert_node(key);

  if (node->value) {
    return false;
  }

  node->value = value;
  return true;
}

/*************************************************************************
 * patricia_trie<T>::find_node
 */
template <typename T, typename Allocator>
auto patricia_trie<T, Allocator>::find_node(
  patricia_key const& key) const noexcept -> const_node_pointer {
  // const_cast is safe here because _get_node doesn't modify the trie
  // when the op is find.  however, this should probably be refactored.
  return const_cast<patricia_trie<T, Allocator>*>(this)->find_node(key);
}

/*************************************************************************
 * patricia_trie<T>::find
 */
template <typename T, typename Allocator>
auto patricia_trie<T, Allocator>::find(patricia_key const& key) noexcept
  -> iterator {
  auto node = find_node(key);

  if (!node || !node->value) {
    return iterator();
  }

  return iterator(node);
}

template <typename T, typename Allocator>
auto patricia_trie<T, Allocator>::find(patricia_key const& key) const noexcept
  -> const_iterator {
  auto node = find_node(key);

  if (!node || !node->value) {
    return const_iterator();
  }

  return const_iterator(node);
}

template <typename T, typename Alloc>
auto patricia_trie<T, Alloc>::erase(iterator const& it) noexcept(
  std::is_nothrow_destructible_v<node_type>) -> size_type {
  SK_PATRICIA_TRACE_MSG("\n[REMOVE] call _get_node\n");

#ifdef SK_PATRICIA_TRACE
  check(root);
#endif

  remove_node(it.get_node());
  return 1;

#ifdef SK_PATRICIA_TRACE
  check(root);
#endif
  return true;
}

/*************************************************************************
 * patricia_trie<T>::remove
 */
template <typename T, typename Alloc>
auto patricia_trie<T, Alloc>::remove(patricia_key const& key) noexcept(
  std::is_nothrow_destructible_v<node_type>) -> bool {
  auto it = find(key);
  if (it == end()) {
    return false;
  }
  erase(it);
  return true;
}

#ifdef SK_PATRICIA_INVARIANT

/*************************************************************************
 * patricia_trie<T>::bugcheck
 */
#  ifdef SK_PATRICIA_HAVE_FMT
template <typename T, typename Allocator>
template <typename... Args>
void patricia_trie<T, Allocator>::bugcheck(std::string const& format,
                                           Args&&... args) const noexcept {
  std::string msg = fmt::format(format, std::forward<Args>(args)...);
  fmt::print("[BUGCHECK] {}\n\n", msg);
#    ifdef SK_PATRICIA_TRACE
  fmt::print("Trie state:\n\n{}\n", print(root));
#    endif
  SK_PATRICIA_INVARIANT(!"invariant failed");
}
#  else
template <typename T, typename Allocator>
template <typename... Args>
void patricia_trie<T, Allocator>::bugcheck(std::string const& format,
                                           Args&&...) const noexcept {
  std::ignore = format;
  SK_PATRICIA_INVARIANT(!format.c_str());
}
#  endif

#endif

#ifdef SK_PATRICIA_TRACE

/*************************************************************************
 * patricia_trie<T>::format_key
 */
template <typename T, typename Allocator>
auto patricia_trie<T, Allocator>::format_key(patricia_key const& k) const
  -> std::string {
  auto& key = k.key;

  auto printable = std::ranges::all_of(key, [](auto c) {
    auto u_c = static_cast<int>(static_cast<unsigned char>(c));
    return std::isalpha(u_c) || std::isblank(u_c);
  });

  std::string ret;

  if (printable) {
    for (auto&& b : key) {
      ret += static_cast<char>(b);
    }
  } else {
    for (auto&& b : key) {
      ret += fmt::format("{:02x}", b);
    }
  }

  ret += "<";
  for (auto&& b : key) {
    ret += fmt::format("{:08b}", b);
  }
  ret += ">";
  return ret;
}

/*************************************************************************
 * patricia_trie<T>::print
 */
template <typename T, typename Allocator>
auto patricia_trie<T, Allocator>::print(const_node_pointer node,
                                        int indent) const -> std::string {
  auto pad = std::string(indent, ' ');

  if (!node) {
    return pad + "<null>\n";
  }

  std::string left, right;

  if (node->edges[0]) {
    left = pad + "|--left:\n" + print(node->edges[0], indent + 4);
  }
  if (node->edges[1]) {
    right = pad + "|--right:\n" + print(node->edges[1], indent + 4);
  }

  return fmt::format("{}node<{}> [bit {}] key=[{}]: parent<{}>\n{}{}", pad,
                     (void*)node, node->bit, format_key(node->key),
                     (void*)node->parent, left, right);
}

/*************************************************************************
 * patricia_trie<T>::check
 */
template <typename T, typename Allocator>
auto patricia_trie<T, Allocator>::check(
  const_node_pointer node,
  std::shared_ptr<std::set<const_node_pointer>> seen) const -> void {
  bool top = !seen;

  if (top) {
    seen = std::make_shared<std::set<const_node_pointer>>();
  }

  if (!seen->insert(node).second) {
    fmt::print("[check: FAILED: node<{}> is in the tree twice]\n", (void*)node);
    SK_PATRICIA_INVARIANT(!"invariant failed");
  }

  if (top && node->parent) {
    fmt::print("[check: FAILED: root node<{}> has parent]\n", (void*)node);
    SK_PATRICIA_INVARIANT(!"invariant failed");
  }

  if (!top && !node->parent) {
    fmt::print("[check: FAILED: sub node<{}> has no parent]\n", (void*)node);
    SK_PATRICIA_INVARIANT(!"invariant failed");
  }

  if (node->parent) {
    if (node->parent->edges[0] != node && node->parent->edges[1] != node) {
      fmt::print("[check: FAILED: node<{}> is not a child of "
                 "parent<{}>]\n",
                 (void*)node, (void*)node->parent);
      SK_PATRICIA_INVARIANT(!"invariant failed");
    }

    if (node->parent->edges[0] == node && node->parent->edges[1] == node) {
      fmt::print("[check: FAILED: node<{}> is both left and "
                 "right child of parent<{}>]\n",
                 (void*)node, (void*)node->parent);
      SK_PATRICIA_INVARIANT(!"invariant failed");
    }
  }

  if (node->edges[0]) {
    check(node->edges[0], seen);
  }

  if (node->edges[1]) {
    check(node->edges[1], seen);
  }

  if (top) {
    fmt::print("[check: ok]\n");
  }
}

#endif // SK_PATRICIA_TRACE

/*************************************************************************
 * patricia_trie<T>::_remove_node
 */
template <typename T, typename Alloc>
auto patricia_trie<T, Alloc>::remove_node(node_pointer node) noexcept(
  std::is_nothrow_destructible_v<node_type>) -> void {
  // Removing this node may cause the parent to be deleted as well, so
  // loop until we find a node we can't delete.
  do {
    SK_PATRICIA_TRACE_MSG("_remove_node: remove node<{}>, parent={} root={}\n",
                          (void*)node, (void*)node->parent, (void*)root);
    SK_PATRICIA_TRACE_MSG("            : trie state:\n{}", print(root));

    /*
     * If this node has two child nodes, don't delete it; set the
     * value to null.
     */
    if (node->edgecount() == 2) {
      SK_PATRICIA_TRACE_MSG("            : node has two children, value?={}\n",
                            node->value.has_value());

      node->clear_value();
      return;
    }

    /*
     * If this node is the root, make its child (if any) the new root.
     */
    if (node == root) {
      SK_PATRICIA_TRACE_MSG("            : node is the root:\n");
      SK_PATRICIA_TRACE_MSG("            :   left={}\n",
                            (void*)node->leftedge());
      SK_PATRICIA_TRACE_MSG("            :   right={}\n",
                            (void*)node->rightedge());

      SK_PATRICIA_INVARIANT(!node->parent);
      SK_PATRICIA_INVARIANT(node->edgecount() <= 1);

      if (node->value) {
        node->clear_value();
      }

      if (node->leftedge()) {
        root = node->detach(node_type::left);
      } else if (node->rightedge()) {
        root = node->detach(node_type::right);
      } else {
        return;
      }

      delete node;
      SK_PATRICIA_TRACE_MSG("            : new root={}\n", (void*)root);
      return;
    }

    if (node->edgecount() == 0) {
      /*
       * Node has no children.
       */
      SK_PATRICIA_TRACE_MSG(
        "            : node is childless and without value\n");

      SK_PATRICIA_INVARIANT(node->parent->leftedge() == node
                            || node->parent->rightedge() == node);

      node->parent->edges[node->parent->which(node)] = nullptr;
      delete std::exchange(node, node->parent);
    } else {
      /*
       * This node is not the root and has exactly one child. Reparent
       * the child to the node's parent.
       */
      auto* p = node->parent;

      SK_PATRICIA_TRACE_MSG("            : node has one child, reparent child "
                            "to node's "
                            "parent:\n");
      SK_PATRICIA_TRACE_MSG("            :   left={}\n", (void*)node->edges[0]);
      SK_PATRICIA_TRACE_MSG("            :   right={}\n",
                            (void*)node->edges[1]);
      SK_PATRICIA_TRACE_MSG("            :   parent->left={}\n",
                            (void*)node->parent->edges[0]);
      SK_PATRICIA_TRACE_MSG("            :   parent->right={}\n",
                            (void*)node->parent->edges[1]);

      node->parent->attach(node->parent->which(node),
                           node->detach(node->leftedge() ? node_type::left
                                                         : node_type::right));
      delete std::exchange(node, p);
    }
  } while (!node->value && !(node->edges[0] && node->edges[1]));
}

/*************************************************************************
 * patricia_trie<T>::find_node
 */
template <typename T, typename Allocator>
auto patricia_trie<T, Allocator>::find_node(patricia_key const& key) noexcept
  -> node_pointer {
  SK_PATRICIA_TRACE_MSG("find_node: start search, root={}\n", (void*)root);

  if (!root) {
    return nullptr;
  }

  auto node = root;
  auto keybits = key.size_bits();

  // Find the node in the trie.
  while (node->bit < keybits) {
    auto& next = node->edges[key.test_bit(node->bit)];

    if (!next) {
      break;
    }

    node = next;
  }

  if (key == node->key) {
    return node;
  }

  return nullptr;
}

/*************************************************************************
 * patricia_trie<T>::upper_bound
 */
template <typename T, typename Allocator>
auto patricia_trie<T, Allocator>::prefix_match(patricia_key const& key) noexcept
  -> node_pointer {
  SK_PATRICIA_TRACE_MSG("prefix_match: start search key<{}>, root={}\n",
                        format_key(key), (void*)root);
  if (!root) {
    return nullptr;
  }

  SK_PATRICIA_TRACE_MSG("{}\n", print(root));

  auto node = root;
  auto keybits = key.size_bits();

  while (node->bit < keybits) {
    SK_PATRICIA_TRACE_MSG("prefix_match: at {}, node->bit={}\n", (void*)node,
                          node->bit);

    auto& next = node->edges[key.test_bit(node->bit)];

    SK_PATRICIA_TRACE_MSG("prefix_match: <{}> <{}>\n", format_key(key),
                          format_key(node->key));

    if (!next) {
      break;
    }

    node = next;
  }

  SK_PATRICIA_TRACE_MSG("prefix_match: search [{}] found node<{}> [{}]\n",
                        format_key(key), (void*)node, format_key(node->key));

  // Walk up the tree until we find a match.
  while (node != nullptr
         && (node->key.bits > keybits || !prefix_compare(node->key, key))) {
    SK_PATRICIA_TRACE_MSG("prefix_match: no match at node<{}>\n    "
                          "node={},\n     key={}\n",
                          (void*)node, format_key(node->key), format_key(key));
    node = node->parent;
  }

  if (node) {
    SK_PATRICIA_TRACE_MSG("prefix_match: match at node<{}>\n    node={},\n     "
                          "key={}\n",
                          (void*)node, format_key(node->key), format_key(key));
  }

  return node;
}

/*************************************************************************
 * patricia_trie<T>::_get_node
 */
template <typename T, typename Allocator>
auto patricia_trie<T, Allocator>::insert_node(patricia_key const& key)
  -> node_pointer {
  auto keylen = key.size_bits();

  if (!root) {
    root = node_type::make_node();
  }

  auto node = root;

  // Find the node in the trie.

  while (node->bit < keylen || !node->value) {
    auto& next = node->edges[key.test_bit(node->bit)];

    if (!next) {
      break;
    }

    node = next;
  }

  auto check_bit = (node->bit < keylen) ? node->bit : keylen;
  bit_t diffbit = detail::bit_diff(key, node->key);
  if (diffbit > check_bit) {
    diffbit = check_bit;
  }

  while (node->parent && (node->parent->bit >= diffbit)) {
    node = node->parent;
  }

  if (diffbit == keylen && node->bit == keylen) {
    return node;
  }

  auto new_node = node_type::make_node(key, keylen);

  if (node->bit == diffbit) {
    new_node->parent = node;

    bool bit = key.test_bit(node->bit);
    node->attach(static_cast<typename node_type::edge>(bit), new_node);
    return new_node;
  }

  if (keylen == diffbit) {
    new_node->parent = node->parent;

    bool bit = node->key.test_bit(keylen);

    if (!node->parent) {
      delete std::exchange(root, new_node);
    } else {
      new_node->edges[bit] = std::exchange(
        node->parent->edges[node->parent->which(node)], new_node);
    }

    node->parent = new_node;
    return new_node;
  }

  bool bit = key.test_bit(diffbit);

  auto* old_parent = node->parent;

  auto n = node_type::make_node(node->parent, bit ? node : new_node,
                                bit ? new_node : node, diffbit);

  // n->bit = diffbit;

  // if (n->parent)
  old_parent->attach(old_parent->which(node), n);
  // attach() calls detach() which resets node->parent
  node->parent = n;
  return new_node;
}

template <typename T>
struct patricia_key_maker {
  template <typename U>
  struct rebind {
    using other = patricia_key_maker<U>;
  };

  auto operator()(T const& v) noexcept -> patricia_key {
    return patricia_key(v);
  }
};

template <std::unsigned_integral T>
struct patricia_key_maker<T> {
  template <typename U>
  struct rebind {
    using other = patricia_key_maker<U>;
  };

  std::byte buf[sizeof(T)];

  patricia_key_maker() noexcept = default;

  auto operator()(T v) noexcept -> patricia_key {
    if constexpr (std::endian::native == std::endian::big) {
      std::memcpy(buf.data(), &v, sizeof(T));
    } else {
      std::byte* ptr = &buf[0];

      for (unsigned i = 0; i < sizeof(T); ++i) {
        *ptr++ = static_cast<std::byte>(v >> (CHAR_BIT * (sizeof(T) - (i + 1)))
                                        & 0xFF);
      }
    }

    return patricia_key(buf);
  }
};

template <std::signed_integral T>
struct patricia_key_maker<T> {
  template <typename U>
  struct rebind {
    using other = patricia_key_maker<U>;
  };

  using unsigned_type = std::make_unsigned_t<T>;
  patricia_key_maker<unsigned_type> km;

  patricia_key_maker() noexcept = default;

  auto operator()(T v) noexcept -> patricia_key {
    // Convert the signed value to a sorted unsigned
    unsigned_type u;
    if (v < 0) {
      u = static_cast<unsigned_type>(-std::numeric_limits<T>::min()) + v;
    } else {
      u = static_cast<unsigned_type>(v) + -std::numeric_limits<T>::min();
    }

    SK_PATRICIA_TRACE_MSG("signed key_maker> v={:0x}, u={:0x}\n", v, u);

    return km(u);
  }
};

/*************************************************************************
 *
 * patricia_set<T>: an std::set<>-type container using a patricia trie.
 */

template <typename T, typename Alloc, bool is_const>
class patricia_set_iterator {
  using iterator_type = patricia_iterator<T, Alloc, is_const>;
  using node_type = patricia_node<T, Alloc>;
  using node_pointer
    = std::conditional_t<is_const, node_type const*, node_type*>;
  iterator_type current;

public:
  using iterator_category = typename iterator_type::iterator_category;
  using difference_type = typename iterator_type::difference_type;
  using value_type = std::conditional_t<is_const, std::add_const_t<T>, T>;
  using const_value_type = std::add_const_t<value_type>;
  using pointer = value_type*;
  using const_pointer = const_value_type*;
  using reference = value_type&;
  using const_reference = const_value_type&;

  explicit patricia_set_iterator() noexcept = default;

  explicit patricia_set_iterator(node_pointer node) noexcept
    : current(iterator_type(node)) {
  }

  auto operator*() noexcept -> reference {
    return *current;
  }

  auto operator*() const noexcept -> const_reference {
    return *current;
  }

  auto operator->() noexcept -> pointer {
    return std::addressof(*current);
  }

  auto operator->() const noexcept -> const_pointer {
    return std::addressof(*current);
  }

  auto operator++() noexcept -> patricia_set_iterator& {
    ++current;
    return *this;
  }

  auto operator++(int) noexcept -> patricia_set_iterator {
    auto ret(*this);
    ++*this;
    return ret;
  }

  template <typename T_, typename Alloc_, bool is_const_>
  friend auto
  operator==(patricia_set_iterator<T_, Alloc_, is_const_> const& a,
             patricia_set_iterator<T_, Alloc_, is_const_> const& b) noexcept
    -> bool;
};

template <typename T, typename Alloc, bool is_const>
auto operator==(patricia_set_iterator<T, Alloc, is_const> const& a,
                patricia_set_iterator<T, Alloc, is_const> const& b) noexcept
  -> bool {
  return a.current == b.current;
}

template <typename T, typename KeyMaker = patricia_key_maker<T>,
          typename Alloc = std::allocator<T>>
class patricia_set {
public:
  using key_type = T;
  using value_type = T;
  using size_type = std::size_t;
  using difference_type = std::ptrdiff_t;
  using reference = value_type&;
  using const_reference = value_type const&;
  using pointer = typename std::allocator_traits<Alloc>::pointer;
  using const_pointer = typename std::allocator_traits<Alloc>::const_pointer;

  using iterator = patricia_set_iterator<T, Alloc, false>;
  using const_iterator = patricia_set_iterator<T, Alloc, true>;

private:
  using trie_type = patricia_trie<T, Alloc>;
  using node_ptr = patricia_node<T, Alloc>*;
  using const_node_ptr = patricia_node<T, Alloc> const*;

  trie_type _trie;

  auto _insert_node(patricia_key const& key) -> node_ptr {
    return _trie.insert_node(key);
  }

  auto _insert_node(value_type const& value) -> node_ptr {
    KeyMaker key_maker;
    auto key = key_maker(value);
    return _insert_node(key);
  }

  template <typename V>
  auto _insert_node(V const& value) -> node_ptr {
    typename KeyMaker::template rebind<V>::other key_maker;
    auto key = key_maker(value);
    return _insert_node(key);
  }

  auto _find_node(patricia_key const& key) noexcept -> node_ptr {
    return _trie.find_node(key);
  }

  auto _find_node(patricia_key const& key) const noexcept -> const_node_ptr {
    return _trie.find_node(key);
  }

  template <typename V>
  auto _find_node(V const& value) noexcept -> node_ptr {
    typename KeyMaker::template rebind<V>::other key_maker;
    auto key = key_maker(value);
    return _find_node(key);
  }

  template <typename V>
  auto _find_node(V const& value) const noexcept -> const_node_ptr {
    typename KeyMaker::template rebind<V>::other key_maker;
    auto key = key_maker(value);
    return _find_node(key);
  }

public:
  patricia_set() noexcept = default;
  ~patricia_set() noexcept(std::is_nothrow_destructible_v<trie_type>) = default;

  template <typename input_iterator>
  patricia_set(input_iterator first, input_iterator last) {
    while (first != last) {
      insert(*first);
      ++first;
    }
  }

  patricia_set(patricia_set const&) = default;

  patricia_set(patricia_set&&) noexcept = default;

  auto operator=(patricia_set const&) -> patricia_set& = default;

  auto operator=(patricia_set&&) noexcept -> patricia_set& = default;

  auto clear() noexcept(std::is_nothrow_destructible_v<value_type>) -> void {
    _trie.clear();
  }

  [[nodiscard]] auto empty() const noexcept -> bool {
    return _trie.empty();
  }

  auto insert(value_type&& value) -> std::pair<iterator, bool> {
    auto node = _insert_node(value);

    SK_PATRICIA_INVARIANT(node != nullptr);

    if (node->value) {
      return std::pair{iterator(node), false};
    }

    node->value = std::move(value);
    return std::pair{iterator(node), true};
  }

  auto insert(value_type const& value) -> std::pair<iterator, bool> {
    auto node = _insert_node(value);

    SK_PATRICIA_INVARIANT(node != nullptr);

    if (node->value) {
      return std::pair{iterator(node), false};
    }

    node->value = value;
    return std::pair{iterator(node), true};
  }

  template <typename V>
  auto find(V const& key) noexcept -> iterator {
    auto node = _find_node(key);

    if (node && node->value.has_value()) {
      return iterator(node);
    }

    return iterator();
  }

  template <typename V>
  auto find(V const& key) const noexcept -> const_iterator {
    auto node = _find_node(key);

    if (node && node->value.has_value()) {
      return const_iterator(node);
    }

    return const_iterator();
  }

  auto prefix_match(value_type const& value) noexcept -> iterator {
    KeyMaker key_maker;
    auto key = key_maker(value);
    auto r = _trie.prefix_match(key);
    if (r) {
      return iterator(r);
    } else {
      return end();
    }
  }

  template <typename V>
  auto prefix_match(V const& value) noexcept -> iterator {
    typename KeyMaker::template rebind<V>::other key_maker;
    auto key = key_maker(value);
    auto r = _trie.prefix_match(key);
    if (r) {
      return iterator(r);
    } else {
      return end();
    }
  }

  template <typename V>
  auto prefix_match(V const& value) const noexcept -> const_iterator {
    typename KeyMaker::template rebind<V>::other key_maker;
    auto key = key_maker(value);
    auto r = _trie.prefix_match(key);
    if (r) {
      return const_iterator(r);
    } else {
      return end();
    }
  }

  template <typename V>
  auto contains(V const& key) const noexcept -> bool {
    auto node = _find_node(key);
    return node && node->value.has_value();
  }

  // Iterator operations.
  auto begin() noexcept -> iterator {
    return iterator(_trie.root_node());
  }

  auto begin() const noexcept -> const_iterator {
    return const_iterator(_trie.root_node());
  }

  auto cbegin() const noexcept -> const_iterator {
    return const_iterator(_trie.root_node());
  }

  auto end() noexcept -> iterator {
    return iterator();
  }

  auto end() const noexcept -> const_iterator {
    return const_iterator();
  }

  auto cend() const noexcept -> const_iterator {
    return const_iterator();
  }

  template <typename V>
  auto erase(V const& key) noexcept(std::is_nothrow_destructible_v<value_type>)
    -> size_type {
    auto node = _find_node(key);

    if (node && node->value.has_value()) {
      _trie.remove_node(node);
      return 1;
    }

    return 0;
  }

  auto erase(iterator pos) noexcept(std::is_nothrow_destructible_v<value_type>)
    -> void {
    _trie.remove_node(pos.get_node());
  }
};

/*************************************************************************
 *
 * patricia_map<K,T>: an std::map<>-type container using a patricia trie.
 */

template <typename T, typename Alloc, bool is_const>
class patricia_map_iterator {
  using iterator_type = patricia_iterator<T, Alloc, is_const>;
  using node_type = patricia_node<T, Alloc>;
  iterator_type current;

public:
  using iterator_category = typename iterator_type::iterator_category;
  using difference_type = typename iterator_type::difference_type;
  using value_type = std::conditional_t<is_const, std::add_const_t<T>, T>;
  using const_value_type = std::add_const_t<value_type>;
  using pointer = value_type*;
  using const_pointer = const_value_type*;
  using reference = value_type&;
  using const_reference = const_value_type&;

  explicit patricia_map_iterator() noexcept = default;

  explicit patricia_map_iterator(node_type* node) noexcept
    : current(iterator_type(node)) {
  }

  auto operator*() noexcept -> reference {
    return *current;
  }

  auto operator*() const noexcept -> const_reference {
    return *current;
  }

  auto operator->() noexcept -> pointer {
    return std::addressof(*current);
  }

  auto operator->() const noexcept -> const_pointer {
    return std::addressof(*current);
  }

  auto operator++() noexcept -> patricia_map_iterator& {
    ++current;
    return *this;
  }

  auto operator++(int) noexcept -> patricia_map_iterator {
    auto ret(*this);
    ++ret;
    return ret;
  }

  template <typename T_, typename Alloc_, bool is_const_>
  friend auto
  operator==(patricia_map_iterator<T_, Alloc_, is_const_> const& a,
             patricia_map_iterator<T_, Alloc_, is_const_> const& b) noexcept
    -> bool;
};

template <typename T, typename Alloc, bool is_const>
auto operator==(patricia_map_iterator<T, Alloc, is_const> const& a,
                patricia_map_iterator<T, Alloc, is_const> const& b) noexcept
  -> bool {
  return a.current == b.current;
}

template <typename K, typename T, typename KeyMaker = patricia_key_maker<K>,
          typename Alloc = std::allocator<std::pair<K, T>>>
class patricia_map {
public:
  using key_type = K;
  using value_type = std::pair<K, T>;
  using size_type = std::size_t;
  using difference_type = std::ptrdiff_t;
  using reference = value_type&;
  using const_reference = value_type const&;
  using pointer = typename std::allocator_traits<Alloc>::pointer;
  using const_pointer = typename std::allocator_traits<Alloc>::const_pointer;

  using iterator = patricia_map_iterator<value_type, Alloc, false>;
  using const_iterator = patricia_map_iterator<value_type, Alloc, true>;

private:
  using trie_type = patricia_trie<value_type, Alloc>;
  using node_ptr = patricia_node<value_type, Alloc>*;
  using const_node_ptr = patricia_node<value_type, Alloc> const*;

  trie_type _trie;

  auto _insert_node(patricia_key const& key) -> node_ptr {
    return _trie.insert_node(key);
  }

  auto _insert_node(key_type const& value) -> node_ptr {
    KeyMaker key_maker;
    auto key = key_maker(value);
    return _insert_node(key);
  }

  template <typename V>
  auto _insert_node(V const& value) -> node_ptr {
    typename KeyMaker::template rebind<V>::other key_maker;
    auto key = key_maker(value);
    return _insert_node(key);
  }

  auto _find_node(patricia_key const& key) noexcept -> node_ptr {
    return _trie.find_node(key);
  }

  auto _find_node(patricia_key const& key) const noexcept -> const_node_ptr {
    return _trie.find_node(key);
  }

  template <typename V>
  auto _find_node(V const& value) noexcept -> node_ptr {
    typename KeyMaker::template rebind<V>::other key_maker;
    auto key = key_maker(value);
    return _find_node(key);
  }

  template <typename V>
  auto _find_node(V const& value) const noexcept -> const_node_ptr {
    typename KeyMaker::template rebind<V>::other key_maker;
    auto key = key_maker(value);
    return _find_node(key);
  }

public:
  patricia_map() noexcept = default;
  ~patricia_map() noexcept(std::is_nothrow_destructible_v<trie_type>) = default;

  template <typename input_iterator>
  patricia_map(input_iterator first, input_iterator last) {
    while (first != last) {
      insert(*first);
      ++first;
    }
  }

  patricia_map(patricia_map const&) = default;

  patricia_map(patricia_map&&) noexcept = default;

  auto operator=(patricia_map const&) -> patricia_map& = default;

  auto operator=(patricia_map&&) noexcept -> patricia_map& = default;

  auto clear() const noexcept(std::is_nothrow_destructible_v<value_type>)
    -> void {
    _trie.clear();
  }

  [[nodiscard]] auto empty() const noexcept -> bool {
    return _trie.empty();
  }

  auto insert(value_type&& value) -> std::pair<iterator, bool> {
    auto node = _insert_node(value.first);

    SK_PATRICIA_INVARIANT(node != nullptr);

    if (node->value) {
      return std::pair{iterator(node), false};
    }

    node->value = std::move(value);
    return std::pair{iterator(node), true};
  }

  auto insert(value_type const& value) -> bool {
    auto node = _insert_node(value.first);

    SK_PATRICIA_INVARIANT(node != nullptr);

    if (node->value) {
      return std::pair{iterator(node), false};
    }

    node->value = value;
    return std::pair{iterator(node), true};
  }

  template <typename V>
  auto find(V const& key) noexcept -> iterator {
    auto node = _find_node(key);

    if (node && node->value.has_value()) {
      return iterator(node);
    }

    return iterator();
  }

  template <typename V>
  auto find(V const& key) const noexcept -> const_iterator {
    auto node = _find_node(key);

    if (node && node->value.has_value()) {
      return const_iterator(node);
    }

    return const_iterator();
  }

  template <typename V>
  auto contains(V const& key) const noexcept -> bool {
    auto node = _find_node(key);
    return node && node->value.has_value();
  }

  auto operator[](key_type const& k) -> T& {
    KeyMaker key_maker;
    auto key = key_maker(k);
    auto node = _trie.insert_node(key);

    if (!node->value) {
      node->value.emplace(std::piecewise_construct, std::forward_as_tuple(k),
                          std::tuple<>());
    }

    return node->value->second;
  }

  // Iterator operations.
  auto begin() noexcept -> iterator {
    return iterator(_trie.root_node());
  }

  auto begin() const noexcept -> const_iterator {
    return const_iterator(_trie.root_node());
  }

  auto cbegin() const noexcept -> const_iterator {
    return const_iterator(_trie.root_node());
  }

  auto end() noexcept -> iterator {
    return iterator();
  }

  auto end() const noexcept -> const_iterator {
    return const_iterator();
  }

  auto cend() const noexcept -> const_iterator {
    return const_iterator();
  }

  template <typename V>
  auto erase(V const& key) noexcept(std::is_nothrow_destructible_v<value_type>)
    -> size_type {
    auto node = _find_node(key);

    if (node && node->value.has_value()) {
      _trie.remove_node(node);
      return 1;
    }

    return 0;
  }

  auto erase(iterator pos) noexcept(std::is_nothrow_destructible_v<value_type>)
    -> void {
    _trie.remove_node(pos.get_node());
  }
};

} // namespace sk
