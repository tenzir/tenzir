name: Docker
on:
  workflow_call:
    inputs:
      config:
        type: string
        required: true

permissions:
  contents: read
  id-token: write
  packages: write

jobs:
  build:
    name: Build Docker Images
    runs-on: depot-ubuntu-24.04
    steps:
      - name: Prevent pushing protected editions to public repos
        run: |
          # Create 'name registry' pairs
          jq -r '.editions[] | select(."image-registries" | length > 0) | .name as $name | ."image-registries"[]? // ."image-registries" | [ $name, . ] | join(" ")' \
            <<< '${{ inputs.config }}' | while read -r name registry; do
            # Explicitly allow tenzir, demo and dev images.
            [[ "${name}" =~ ^tenzir(|-dev|-deps|-node|-de|-node-de|-demo)$ ]] && continue
            # Explicitly allow private registries.
            [[ "${registry}" == "622024652768.dkr.ecr.eu-west-1.amazonaws.com" ]] && continue
            echo "::error Pushing ${name} to ${registry} is forbidden"
            exit 1
          done
      - name: Checkout
        uses: actions/checkout@v4
      - name: Checkout submodules
        run: |
          git config --global --add safe.directory '*'
          git submodule update --init --recursive libtenzir
          git submodule update --init --recursive plugins
          git submodule update --init --recursive tenzir
      - name: Tailscale
        if: false
        uses: tailscale/github-action@v3
        with:
          oauth-client-id: ${{ secrets.TS_OAUTH_CLIENT_ID }}
          oauth-secret: ${{ secrets.TS_OAUTH_SECRET }}
          tags: tag:ci
          version: 1.66.4
          args: --ssh
      - name: Configure ssh-agent
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.TENZIR_PLUGINS_DEPLOY_KEY }}
      - name: Update submodules
        run: |
          git submodule update --init --recursive contrib/tenzir-plugins
      - name: Setup Depot
        uses: depot/setup-action@v1
      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.TENZIR_BOT_GITHUB_TOKEN }}
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ vars.DOCKERHUB_USER }}
          password: ${{ secrets.DOCKERHUB_PASSWORD }}
      - name: Build and push images
        env:
          DEPOT_PROJECT_ID: ${{ vars.DEPOT_PROJECT_ID }}
        run: |
          cmake_version_args="-DTENZIR_VERSION_BUILD_METADATA:STRING=${{ fromJSON(inputs.config).version-build-metadata }}"
          jq -r '.editions[] | .name as $name | .target as $target | ."image-registries" | select(length > 0) | [ $name, $target, (. | join(" ")) ] | join("|")' \
            <<< '${{ inputs.config }}' | while IFS='|' read -r name target registries; do
            # Build tags array
            tags=""
            for registry in $registries; do
              for tag in ${{ join(fromJSON(inputs.config).tags, ' ') }}; do
                tags="${tags} --tag ${registry}/tenzir/${name}:${tag}"
              done
            done
            # Use depot build for multi-platform builds
            depot build \
              --platform linux/amd64,linux/arm64 \
              --target "${target}" \
              --build-arg "TENZIR_BUILD_OPTIONS=${cmake_version_args}" \
              --push \
              ${tags} \
              .
          done

  push-manifest:
    name: Collect Images
    runs-on: ubuntu-latest
    needs:
      - build
    outputs:
      images: ${{ steps.collect-images.outputs.images }}
    steps:
      - name: Collect images for signing
        id: collect-images
        run: |
          # Generate list of all manifest images (without arch suffix)
          jq -r '.editions[] | .name as $name | ."image-registries"[]? | [ $name, . ] | join(" ")' \
            <<< '${{ inputs.config }}' > /tmp/editions.txt
          images=()
          while read -r name registry; do
            for tag in ${{ join(fromJSON(inputs.config).tags, ' ') }}; do
              images+=("${registry}/tenzir/${name}:${tag}")
            done
          done < /tmp/editions.txt
          printf '%s\n' "${images[@]}" | jq -R . | jq -sc '.' > /tmp/images.json
          echo "images=$(cat /tmp/images.json)" >> "$GITHUB_OUTPUT"

  sign-images:
    name: Sign Images
    runs-on: ubuntu-latest
    needs:
      - push-manifest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Login to registries
        uses: ./.github/actions/registry-login
        with:
          config: ${{ inputs.config }}
          ghcr-token: ${{ secrets.TENZIR_BOT_GITHUB_TOKEN }}
          dockerhub-user: ${{ vars.DOCKERHUB_USER }}
          dockerhub-password: ${{ secrets.DOCKERHUB_PASSWORD }}

      # --- Cosign Signing (for general use with `cosign verify`) ---
      - name: Install Cosign
        uses: sigstore/cosign-installer@v3
      - name: Sign images with Cosign (keyless OIDC)
        # Keyless signing uses GitHub Actions OIDC identity.
        # Verify with:
        #   cosign verify \
        #     --certificate-identity-regexp="https://github.com/tenzir/tenzir/.*" \
        #     --certificate-oidc-issuer="https://token.actions.githubusercontent.com" \
        #     <image>
        run: |
          for image in $(echo '${{ needs.push-manifest.outputs.images }}' | jq -r '.[]'); do
            echo "::notice Signing ${image} with Cosign (keyless)"
            cosign sign --yes "${image}"
          done

      # --- Sigstore-format Signing (for Podman automatic verification) ---
      # This creates sigstore-format signatures stored directly in the registry.
      # No lookaside server needed - signatures are stored as OCI artifacts.
      # Users configure /etc/containers/policy.json with the public key
      # and set use-sigstore-attachments: true in registries.d.
      - name: Sign images with sigstore format (Podman-compatible)
        env:
          COSIGN_PASSWORD: ${{ secrets.CONTAINER_SIGNING_KEY_PASSWORD }}
        run: |
          echo "${{ secrets.CONTAINER_SIGNING_KEY }}" > /tmp/signing-key.pem
          for image in $(echo '${{ needs.push-manifest.outputs.images }}' | jq -r '.[]'); do
            echo "::notice Signing ${image} with sigstore format for Podman"
            cosign sign --yes --key /tmp/signing-key.pem "${image}"
          done
          rm -f /tmp/signing-key.pem
