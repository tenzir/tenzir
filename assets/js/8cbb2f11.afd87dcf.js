"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[868],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=p(n),h=i,m=d["".concat(l,".").concat(h)]||d[h]||u[h]||r;return n?a.createElement(m,o(o({ref:t},c),{},{components:n})):a.createElement(m,o({ref:t},c))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var p=2;p<r;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},65456:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>p});var a=n(87462),i=(n(67294),n(3905));const r={sidebar_position:5},o="Tune",s={unversionedId:"setup-vast/tune",id:"setup-vast/tune",title:"Tune",description:"This section describes tuning knobs that have a notable effect on system",source:"@site/docs/setup-vast/tune.md",sourceDirName:"setup-vast",slug:"/setup-vast/tune",permalink:"/docs/setup-vast/tune",draft:!1,editUrl:"https://github.com/tenzir/vast/tree/master/web/docs/setup-vast/tune.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"docsSidebar",previous:{title:"Configure",permalink:"/docs/setup-vast/configure"},next:{title:"Monitor",permalink:"/docs/setup-vast/monitor"}},l={},p=[{value:"Batching: Table Slices",id:"batching-table-slices",level:2},{value:"Size",id:"size",level:3},{value:"Import Timeout",id:"import-timeout",level:3},{value:"Persistent Storage",id:"persistent-storage",level:2},{value:"Memory usage and caching",id:"memory-usage-and-caching",level:2},{value:"Caching",id:"caching",level:3},{value:"Catalog",id:"catalog",level:3},{value:"Tune sketch parameters",id:"tune-sketch-parameters",level:3},{value:"Example",id:"example",level:4},{value:"Shutdown",id:"shutdown",level:2},{value:"Logging",id:"logging",level:2},{value:"Rebuild Partitions",id:"rebuild-partitions",level:2}],c={toc:p};function u(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"tune"},"Tune"),(0,i.kt)("p",null,"This section describes tuning knobs that have a notable effect on system\nperformance."),(0,i.kt)("h2",{id:"batching-table-slices"},"Batching: Table Slices"),(0,i.kt)("p",null,"VAST processes events in batches. Because the structured data has the shape of a\ntable, we call these batches ",(0,i.kt)("em",{parentName:"p"},"table slices"),". The following options control their\nshape and behavior."),(0,i.kt)("admonition",{title:"Implementation Note",type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Table slices are implemented as ",(0,i.kt)("em",{parentName:"p"},"Record Batches")," in Apache Arrow.")),(0,i.kt)("h3",{id:"size"},"Size"),(0,i.kt)("p",null,"Most components in VAST operate on table slices, which makes the table slice\nsize a fundamental tuning knob on the spectrum of throughput and latency. Small\ntable slices allow for shorter processing times, resulting in more scheduler\ncontext switches and a more balanced workload. But the increased pressure on the\nscheduler comes at the cost of throughput. Conversely, a large table slice size\ncreates more work for each actor invocation and makes them yield less frequently\nto the scheduler. As a result, other actors scheduled on the same thread may\nhave to wait a little longer."),(0,i.kt)("p",null,"The option ",(0,i.kt)("inlineCode",{parentName:"p"},"vast.import.batch-size")," sets an upper bound for the number of events\nper table slice."),(0,i.kt)("p",null,"The option merely controls number of events per table slice, but not\nnecessarily the number of events until a component forwards a batch to the next\nstage in a stream. The CAF streaming framework uses a credit-based flow-control\nmechanism to determine buffering of tables slices."),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Setting ",(0,i.kt)("inlineCode",{parentName:"p"},"vast.import.batch-size")," to 0 causes the table slice size to be\nunbounded and leaves it to other parameters to determine the actual table slice\nsize.")),(0,i.kt)("h3",{id:"import-timeout"},"Import Timeout"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"vast.import.batch-timeout")," option sets a timeout for forwarding buffered\ntable slices to the remote VAST node. If the timeout fires before a table slice\nreaches ",(0,i.kt)("inlineCode",{parentName:"p"},"vast.import.batch-size"),", then the table slice will contain fewer events\nand ship immediately."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"vast.import.read-timeout")," option determines how long a call to read data\nfrom the input will block. After the read timeout elapses, VAST tries again at a\nlater."),(0,i.kt)("h2",{id:"persistent-storage"},"Persistent Storage"),(0,i.kt)("p",null,"VAST arranges data in horizontal ",(0,i.kt)("em",{parentName:"p"},"partitions")," for sharding. The persistent\nrepresentation of partition is a single file consists containing a set table\nslices all having the same schema. The ",(0,i.kt)("inlineCode",{parentName:"p"},"store")," plugin defines the on-disk\nformat. VAST currently ships with two implementations:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Segment"),": writes Apache Arrow IPC with a thin wrapper"),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Apache Parquet"),": writes ",(0,i.kt)("a",{parentName:"li",href:"https://parquet.apache.org/"},"Parquet")," files")),(0,i.kt)("p",null,"VAST defaults to the Segment store. Enable the Parquet store by loading the\nplugin and adjusting ",(0,i.kt)("inlineCode",{parentName:"p"},"vast.store-backend"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"vast:\n  plugins:\n    - parquet\n  store-backend: parquet\n")),(0,i.kt)("p",null,"There's an inherent space-time tradeoff between the Segment and Parquet store\nthat affects CPU, memory, and storage characteristics. Compared to the Segment\nstore, Parquet differs as follows:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Parquet files occupy ~40% less space, which also reduces I/O pressure during\nquerying."),(0,i.kt)("li",{parentName:"ol"},"Parquet utilizes more CPU cycles during ingest (~10%) and querying.")),(0,i.kt)("p",null,"Parquet has the major advantage that it's the de-facto standard for\nencoding columnar data in modern data architectures. This allows other\napplications that support reading from Parquet ",(0,i.kt)("em",{parentName:"p"},"native")," access to the data."),(0,i.kt)("admonition",{title:"Recommendation",type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Use Parquet when:"),(0,i.kt)("ol",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ol"},"Storage is scarce, and you want to increase data retention"),(0,i.kt)("li",{parentName:"ol"},"Workloads are I/O-bound and you have available CPU"),(0,i.kt)("li",{parentName:"ol"},"Reading data with with off-the-shelf data science tools is a use case"))),(0,i.kt)("p",null,"VAST supports ",(0,i.kt)("a",{parentName:"p",href:"#rebuild-partitions"},"rebuilding the entire database")," in case you\nwant to switch to a different store format. However, VAST works perfectly fine\nwith a mixed-storage configuration, so a full rebuild is not required."),(0,i.kt)("h2",{id:"memory-usage-and-caching"},"Memory usage and caching"),(0,i.kt)("p",null,"The amount of memory that a VAST server process is allowed to use can currently\nnot be configured directly as a configuration file option. Instead of such a\ndirect tuning knob, the memory usage can be influenced through the configuration\nof the caching, catalog and disk monitor features."),(0,i.kt)("h3",{id:"caching"},"Caching"),(0,i.kt)("p",null,"VAST groups table slices with the same schema in a ",(0,i.kt)("em",{parentName:"p"},"partition"),". When building a\npartition, the parameter ",(0,i.kt)("inlineCode",{parentName:"p"},"vast.max-partition-size")," sets an upper bound on the\nnumber of records in a partition, across all table slices. The parameter\n",(0,i.kt)("inlineCode",{parentName:"p"},"vast.active-partition-timeout")," provides a time-based upper bound: once reached,\nVAST considers the partition as complete, regardless of the number of records."),(0,i.kt)("p",null,"A LRU cache of partitions accelerates queries to recently used partitions. The\nparameter ",(0,i.kt)("inlineCode",{parentName:"p"},"vast.max-resident-partitions")," controls the number of partitions in\nthe LRU cache."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Run ",(0,i.kt)("inlineCode",{parentName:"p"},"vast flush")," to force VAST to write all active partitions to disk\nimmediately. The command returns only after all active partitions were flushed\nto disk.")),(0,i.kt)("h3",{id:"catalog"},"Catalog"),(0,i.kt)("p",null,"The catalog manages partition meta data and is responsible for deciding whether\na partition qualifies for a certain query. It does so by maintaining ",(0,i.kt)("em",{parentName:"p"},"sketch"),"\ndata structures (e.g., Bloom filters, summary statistics) for each partition.\nSketches are highly space-efficient at the cost of being probabilistic and\nyielding false positives."),(0,i.kt)("p",null,"Due to this characteristic sketches can grow sub-linear, doubling the number of\nevents in a sketch does not lead to a doubling of the memory requirement.\nBecause the catalog must be traversed in full for a given query it needs to be\nmaintained in active memory to provide high responsiveness."),(0,i.kt)("p",null,"As a consequence, the overall amount of data in a VAST instance and the\n",(0,i.kt)("inlineCode",{parentName:"p"},"max-partition-size")," determine the memory requirements of the catalog. The\noption ",(0,i.kt)("inlineCode",{parentName:"p"},"max-partition-size")," is inversely linked to the number of sketches in the\ncatalog. That means increasing the ",(0,i.kt)("inlineCode",{parentName:"p"},"max-partition-size")," is an effective method\nto reduce the memory requirements for the catalog."),(0,i.kt)("h3",{id:"tune-sketch-parameters"},"Tune sketch parameters"),(0,i.kt)("p",null,"A false positive can have substantial impact on the query latency by\nmaterializing irrelevant partitions, which involves unnecessary I/O. Based on\nthe cost of I/O, this penalty may be substantial. Conversely, reducing the false\npositive rate increases the memory consumption, leading to a higher resident set\nsize and larger RAM requirements."),(0,i.kt)("p",null,"You can control this space-time trade-off in the configuration section\n",(0,i.kt)("inlineCode",{parentName:"p"},"vast.index")," by specifying index ",(0,i.kt)("em",{parentName:"p"},"rules"),". Each rule corresponds to one sketch\nand consists of the following components:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"targets"),": a list of extractors to describe the set of fields whose values to\nadd to the sketch."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"fp-rate"),": an optional value to control the false-positive rate of the sketch.")),(0,i.kt)("p",null,"VAST does not create field-level sketches unless a dedicated rule with a\nmatching target configuration exists."),(0,i.kt)("h4",{id:"example"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"vast:\n  index:\n    # Set the default false-positive rate for type-level synopses\n    default-fp-rate: 0.001\n    rules:\n      - targets:\n          # field synopses: need to specify fully qualified field name\n          - suricata.http.http.url\n        fp-rate: 0.005\n      - targets:\n          - :addr\n        fp-rate: 0.1\n")),(0,i.kt)("p",null,"This configuration includes two rules (= two sketches), where the first rule\nincludes a field extractor and the second a type extractor. The first rule\napplies to a single field, ",(0,i.kt)("inlineCode",{parentName:"p"},"suricata.http.http.url"),", and has false-positive rate\nof 0.5%. The second rule creates one sketch for all fields of type ",(0,i.kt)("inlineCode",{parentName:"p"},"addr")," that\nhas a false-positive rate of 10%."),(0,i.kt)("h2",{id:"shutdown"},"Shutdown"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"stop")," command gracefully brings down a VAST server that has been started\nwith the ",(0,i.kt)("inlineCode",{parentName:"p"},"start")," command."),(0,i.kt)("p",null,"It is also possible to send a signal ",(0,i.kt)("inlineCode",{parentName:"p"},"SIGINT(2)")," to the ",(0,i.kt)("inlineCode",{parentName:"p"},"vast")," process instead\nof using ",(0,i.kt)("inlineCode",{parentName:"p"},"vast stop"),", but in only works on the same machine that runs the\nserver process. We recommend using ",(0,i.kt)("inlineCode",{parentName:"p"},"vast stop"),", as it also works over the wire."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"stop")," command blocks until the server process has terminated, and returns\na zero exit code upon success, making it suitable for use in launch system\nscripts."),(0,i.kt)("p",null,"The configuration option ",(0,i.kt)("inlineCode",{parentName:"p"},"vast.shutdown-grace-period")," sets the time to wait\nuntil component shutdown finishes cleanly before inducing a hard kill."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"The server waits for ongoing import processes to terminate before shutting down\nitself. In case an import process is hanging, you can always terminate the\nhanging process manually to shutdown the server.")),(0,i.kt)("h2",{id:"logging"},"Logging"),(0,i.kt)("p",null,"The VAST server writes log files into a file named ",(0,i.kt)("inlineCode",{parentName:"p"},"server.log")," in the database\ndirectory by default. Set the option ",(0,i.kt)("inlineCode",{parentName:"p"},"vast.log-file")," to change the location of\nthe log file."),(0,i.kt)("p",null,"VAST client processes do not write logs by default. Set the option\n",(0,i.kt)("inlineCode",{parentName:"p"},"vast.client-log-file")," to enable logging. Note that relative paths are\ninterpreted relative to the current working directory of the client process."),(0,i.kt)("p",null,"Server log files rotate automatically after 10 MiB. The option\n",(0,i.kt)("inlineCode",{parentName:"p"},"vast.disable-log-rotation")," allows for disabling log rotation entirely, and the\noption ",(0,i.kt)("inlineCode",{parentName:"p"},"vast.log-rotation-threshold")," sets the size limit when a log file should\nbe rotated."),(0,i.kt)("p",null,"VAST processes log messages in a dedicated thread, which by default buffers up\nto 1M messages for servers, and 100 for clients. The option\n",(0,i.kt)("inlineCode",{parentName:"p"},"vast.log-queue-size")," controls this setting."),(0,i.kt)("h2",{id:"rebuild-partitions"},"Rebuild Partitions"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"rebuild")," command re-ingests events from existing partitions and replaces\nthem with new partitions. This makes it possible to upgrade persistent state to\na newer version, or recreate persistent state after changing configuration\nparameters, e.g., switching from the Feather to the Parquet store backend.\nRebuilding partitions also recreates their sketches. The process takes place\nasynchronously in the background."),(0,i.kt)("admonition",{title:"Upgrade from VAST v1.x partitions",type:"info"},(0,i.kt)("p",{parentName:"admonition"},"You can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"rebuild")," command to upgrade your VAST v1.x partitions to v2.x,\nwhich yield better compression and have a streamlined representation. We\nrecommend this to be able to use newer features that do not work with v1.x\npartitions.")),(0,i.kt)("p",null,"This is how you run it:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"vast rebuild [--all] [--undersized] [--parallel=<number>] [<expression>]\n")),(0,i.kt)("p",null,"A rebuild is not only useful when upgrading outdated partitions, but also when\nchanging parameters of up-to-date partitions. Use the ",(0,i.kt)("inlineCode",{parentName:"p"},"--all")," flag to extend a\nrebuild operation to ",(0,i.kt)("em",{parentName:"p"},"all")," partitions. (Internally, VAST versions the partition\nstate via FlatBuffers. An outdated partition is one whose version number is not\nthe newest.)"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"--undersized")," flag causes VAST to only rebuild partitions that are under\nthe configured partition size limit ",(0,i.kt)("inlineCode",{parentName:"p"},"vast.max-partition-size"),"."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"--parallel")," options is a performance tuning knob. The parallelism level\ncontrols how many sets of partitions to rebuild in parallel. This value defaults\nto 1 to limit the CPU and memory requirements of the rebuilding process, which\ngrow linearly with the selected parallelism level."),(0,i.kt)("p",null,"An optional expression allows for restricting the set of partitions to rebuild.\nVAST performs a catalog lookup with the expression to identify the set of\ncandidate partitions. This process may yield false positives, as with regular\nqueries, which may cause unaffected partitions to undergo a rebuild. For\nexample, to rebuild outdated partitions containing ",(0,i.kt)("inlineCode",{parentName:"p"},"suricata.flow")," events\nolder than 2 weeks, run the following command:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"vast rebuild '#type == \"suricata.flow\" && #import_time < 2 weeks ago'\n")))}u.isMDXComponent=!0}}]);